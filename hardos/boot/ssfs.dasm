
;
; Super Simple File System
; Copyright (C) 1984 Harold Innovation Technologies.
;
; Authors: Daniel Keep.
;

; This driver file only provides basic read access to a SSFS.

;
; State for the current file handle.
;

:HANDLE         .equ BOOT_FS_VARS
:NEXT_SECTOR    .equ HANDLE + 1
:WORDS_LEFT     .equ NEXT_SECTOR + 1

;
; Variables stored in the boot sector
;

:BS_MAGIC_0     .equ 0x7002
:BS_MAGIC_1     .equ 0x7003
:BS_VERSION     .equ 0x7004
:BS_FIRST_FREE  .equ 0x7005
:BS_FIRST_RAW   .equ 0x7006

;
; Landing pads.
;

.org fs_init
:land_init          set pc, ssfs_init
.org fs_find_file
:land_find_file     set pc, ssfs_find_file
.org fs_open_handle
:land_open_handle   set pc, ssfs_open_handle
.org fs_read
:land_read          set pc, ssfs_read
.org fs_get_driver
:land_get_driver    set pc, ssfs_get_driver

;
; Implementation.
;

.org BOOT_FS_CODE

                    ; fs_init()
                    ; = A success
:ssfs_init          ; First, check signature and version
                    ifn [BS_MAGIC_0], 0x5353
                        set pc, .badsig
                    ifn [BS_MAGIC_1], 0x4653
                        set pc, .badsig
                    
                    set a, [BS_VERSION]
                    shr a, 8
                    ifn a, 1
                        set pc, .badver
                    
                    ; All good.  Read the first directory sector into memory
                    set a, 1
                    set b, BOOT_BUFFER_FS_0
                    jsr dd_read_sector
                    
                    ; Done.
                    set a, 1
                    set pc, pop
                    
:.badsig            set a, 0
                    set pc, pop
                    
:.badver            set a, 0
                    set pc, pop
                    
                    ; fs_find_file(A path)
                    ; = A success, B handle
                    ; * A B C
:ssfs_find_file     ; We're only going to bother searching the first directory
                    ; sector.  If files the bootloader needs are outside that,
                    ; well, that's just too bad.  In a later version, we can 
                    ; make the effort of reading in additional sectors.
                    set push, i
                    set push, a
                    set i, 0xffff
                    set c, 6
                    
:.nextfile          add i, 1
                    ife i, 8
                        set pc, .notfound
                    set a, peek
                    set b, i
                    mul b, 8
                    add b, [BOOT_BUFFER_FS_0]
                    set c, 6
                    jsr csz_eql
                    ife a, 0
                        set pc, .nextfile
                        
:.found             set b, i
                    mul b, 8
                    add b, [BOOT_BUFFER_FS_0]
                    set pc, .return
                        
:.notfound          set a, 0
                    ; set pc, .return
                    
:.return            add sp, 1
                    set i, pop
                    set pc, pop
                    
                    ; fs_open_handle(A handle)
                    ; * A B
:ssfs_open_handle   set [HANDLE], a
                    set [NEXT_SECTOR], [a+6]
                    set b, [a+7]
                    shr b, 1
                    set [WORDS_LEFT], b
                    set pc, pop
                    
                    ; fs_read()
                    ; = A success, B buffer, C words_read
                    ; * A B C
:ssfs_read          ; If there is nothing left to read, signal eof.
                    ife [WORDS_LEFT], 0
                        set pc, .ateof
                        
                    ; Read in the next sector
                    set a, [NEXT_SECTOR]
                    set b, BOOT_BUFFER_FS_1
                    jsr dd_read_sector
                    ifn a, 1
                        set pc, .failed
                        
                    ; Update next sector
                    set [NEXT_SECTOR], [BOOT_BUFFER_FS_1+1]
                        
                    set a, 1
                    set b, BOOT_BUFFER_FS_1
                    add b, 1
                    set c, 511 ; HACK!
                    set pc, pop
                    
:.failed            set a, 0
                    set pc, pop
                    
:.ateof             set a, 1
                    set b, 0
                    set c, 0
                    set pc, pop
                    
                    ; fs_get_drive()
                    ; = A filename
:ssfs_get_driver    set a, FN_DRIVER
                    set pc, pop

                    ; csz_eq(A, B, C length)
                    ; = A equal?
                    ; Compares two compact zero-terminated string for 
                    ; equality.
:csz_eql            ife c, 0
                        set pc, .equal
                    ifn [a], [b]
                        set pc, .noteq
                    add a, 1
                    add b, 1
                    set pc, csz_eql
                    
:.equal             set a, 1
                    set pc, pop
                    
:.noteq             set a, 0
                    set pc, pop

                    ; "SSFS\0\0\0\0DRV\0"
:FN_DRIVER          dat 0x5353,0x4653,0x0000,0x0000,0x4452,0x5600
                    
                    ; "Bad disk format.\0"
:ERR_BADFORMAT      dat 0x4261,0x6420,0x6469,0x736b,0x2066,0x6f72,0x6d61,0x742e
                    dat 0x0020,0x0000    
                    
.org BOOT_FS_END
                    sub pc, 1
