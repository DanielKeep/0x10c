
.include "loader.i"
.include "../kernel/syscall.i"

;
; Variables.
;

.equ scr_id         BOOT_VARS
.equ scr_cur        scr_id + 1
.equ scr_format     scr_cur + 1

.equ kb_id          scr_format + 1

.equ boot_dev_id    kb_id + 1

.equ dd_drv_offset  boot_dev_id + 1
.equ fs_drv_offset  dd_drv_offset + 1

;
; Constants.
;

.equ TRUE           1
.equ FALSE          0

.equ SUCCESS        1
.equ FAILURE        0

.equ LOAD_BASE      0x0000
.equ SCR_BASE       0x8000
.equ F_Wz           0xF000

.equ LEM_MEM_MAP_SCREEN     0
.equ LEM_MEM_MAP_FONT       1
.equ LEM_MEM_MAP_PALETTE    2
.equ LEM_SET_BORDER_COLOR   3

.org BOOT_ORG

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; boot(...)
                    ; -> DNR
                    ;  * A B
                    ;
                    ; Begins the boot process.  We expect the following stack
                    ; layout:
                    ;
                    ; PICK 0:   boot_device_id
                    ; PICK 1:   scr_id
                    ; PICK 2:   scr_cur
                    ; PICK 3:   scr_format
                    ; PICK 4:   kb_id
                    ;

:boot               set a, pop
                    set [boot_dev_id], a
                    set [scr_id], pop
                    set [scr_cur], pop
                    set [scr_format], pop
                    set [kb_id], pop
                    set sp, 0xffff ; throw away any extra parameters

                    ; We don't need to initialise the screen since the boot ROM
                    ; should have done it for us.

                    ; Initialise the disk driver.
                    jsr dd_init
                    ifn a, 1
                        set pc, .ddfail

                    ; Read second sector
                    set a, 1
                    set b, BOOT_HIGH
                    jsr dd_read_sector

                    set pc, boot2

:.ddfail            set a, MSG_DD_FAIL
                    jsr scr_putpsz
                    jsr halt

:MSG_DD_FAIL        dat p"Disk drive failure.\0"

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; scr_putpsz(A = string) -> -
                    ;
                    ; Writes a packed, zero-terminated string to the screen.
                    ; This function will interpret newlines and print everything
                    ; else.
                    ;
                    ; TODO: screen scrolling.
                    ;
                    
:scr_putpsz         ; A = current screen address / offset
                    ; B = format
                    ; C = message
                    ; I = character
                    set push, i
                    
                    set c, a
                    set a, [scr_cur]
                    add a, SCR_BASE
                    
                    set b, [scr_format]
                    
                    ; Put high character
:.next_word         set i, [c]
                    shr i, 8
                    and i, 0x7f
                    
                    ife i, 0
                        set pc, .return
                    ife i, '\n'
                        set pc, .nl_h
                    
                    bor i, b
                    set [a], i
                    
                    ; Put low character
:.next_l            add a, 1
                    set i, [c]
                    and i, 0x7f
                    
                    ife i, 0
                        set pc, .return
                    ife i, '\n'
                        set pc, .nl_l
                    
                    bor i, b
                    set [a], i
                    
:.next_h            add a, 1
                    add c, 1
                    set pc, .next_word
                    
                    ; High newline
:.nl_h              jsr .nl
                    set pc, .next_l
                    
                    ; Low newline
:.nl_l              jsr .nl
                    set pc, .next_h
                    
                    ; Common newline code for either
:.nl                set push, a
                    set push, c
                    jsr scr_nl
                    set c, pop
                    set b, [scr_format]
                    set a, pop
                    set pc, pop
                    
                    ; Calls scr_advance_from.  Note that we're calling a
                    ; variant that explicitly preserves B and C.
:.adv               sub a, SCR_BASE ; adjust back to raw offset
                    jsr scr_advance_from_PrBC ; A = new offset
                    add a, SCR_BASE ; adjust back to address
                    set pc, pop
                    
                    ; Done
:.return            set i, pop
                    set pc, pop
                    
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; scr_advance_from(A = current offset) -> A = new offset
                    ;
                    ; Advances the given cursor to the next position, scrolling
                    ; the screen if necessary.  Note that this ignores the
                    ; current value of scr_cursor.
                    ;
                    
:scr_advance_from_PrBC
                    add a, 1
                    
                    ; If we are now at SCR_BASE + 32*12, we need to scroll the
                    ; screen up one line and subtract 32 from the cursor.
                    ifn a, 32*12
                        set pc, pop
                    
                    set push, b
                    set push, c
                    jsr scr_scroll_up
                    set c, pop
                    set b, pop
                    sub a, 32
                    set pc, pop
                    
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; scr_nl_from(A = current offset) -> A = new offset
                    ;
                    ; Moves the current screen cursor to the next line.
                    ;
                    
:scr_nl_from_PrBC   and a, 0xFFDF
                    add a, 32
                    ifl a, 32*12
                        set pc, pop
                    
                    ; Need to scroll up.
                    set push, b
                    set push, c
                    jsr scr_scroll_up
                    set c, pop
                    set b, pop
                    sub a, 32
                    set pc, pop
                    
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; scr_scroll_up() -> -
                    ;
                    ; Scrolls all lines on screen up by one.
                    ;
                    
:scr_scroll_up      ; We can do this by doing a memcpy from 0x8000+32 to
                    ; 0x8000, length 32*11; then, we memset 0x8000+32*11.
                    set a, SCR_BASE
                    set b, SCR_BASE+32
                    set c, 32*11
                    jsr memcpy
                    
                    set a, SCR_BASE+32*11
                    set b, 0
                    set c, 32
                    jsr memset
                    
                    set pc, pop
                    
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; Here's the way this words.  BOOT_CUTOFF will always be set
                    ; to an address at or before 0x7200.  All code needed to
                    ; initialise the disk drive and read in the portions of the
                    ; bootloader above 0x7200 *must* fit below this cut-off.
                    ; The screen initialisation got thrown in because there was
                    ; room; waste not, want not!
.org BOOT_CUTOFF

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; boot2()
                    ; -> DNR
                    ;  * A B X
                    ;
                    ; Continues boot.
                    ;

:boot2              ; Initialise the filesystem driver.
                    jsr fs_init
                    ifn a, SUCCESS
                        set pc, .fsfail

                    ; Device driver and filesystem init'ed OK.
                    ; Locate the kernel and load into memory.
                    set x, LOAD_BASE
                    set a, FN_KERNEL
                    set b, x
                    jsr load_file
                    ifn a, SUCCESS
                        set pc, .dnl_kernel

                    add x, b

                    jsr dd_get_driver
                    set b, x
                    jsr load_file
                    ifn a, SUCCESS
                        set pc, .dnl_dd

                    add x, b

                    jsr fs_get_driver
                    set b, x
                    jsr load_file
                    ifn a, SUCCESS
                        set pc, .dnl_fs

                    ; All done!
                    jsr start_kernel

:.fsfail            set a, MSG_FS_FAIL
                    jsr scr_putpsz
                    jsr halt

:.dnl_kernel        set a, MSG_DNL_KERN
                    set pc, .dnl_tail

:.dnl_dd            set a, MSG_DNL_DD
                    set pc, .dnl_tail

:.dnl_fs            set a, MSG_DNL_FS
                    set pc, .dnl_tail

:.dnl_tail          jsr scr_putpsz
                    jsr scr_nl
                    set a, MSG_CANT_BOOT
                    jsr scr_putpsz
                    jsr halt

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; load_file(A = path, B = dest)
                    ; -> A = success, B = size
                    ;  * A B C X Y
                    ;
                    ; Loads a file into memory at the specified base address.
                    ; Returns the number of words loaded.
                    ;

:load_file          set push, x
                    set push, y
                    set x, b

                    jsr fs_find_file
                    ife a, FAILURE
                        set pc, .fail0

                    set a, b
                    jsr fs_open_handle
                    ife a, FAILURE
                        set pc, .fail0

                    set push, a
                    set y, 0
:.next              set a, peek
                    jsr fs_read ; -> A = success, B = buffer, C = words_read
                    ife a, FAILURE
                        set pc, .fail1

                    ife c, 0
                        set pc, .done

                    set a, x
                    add x, c
                    add y, c
                    jsr memcpy
                    set pc, .next

:.fail0             set y, pop
                    set x, pop
                    set pc, pop

:.fail1             add sp, 1
                    set a, FAILURE
                    set y, pop
                    set x, pop
                    set pc, pop

:.done              add sp, 1
                    set a, SUCCESS
                    set b, y
                    set y, pop
                    set x, pop
                    set pc, pop


                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; start_kernel()
                    ; -> DNR
                    ;  * -
                    ;
                    ; Starts the kernel up.
                    ;

:start_kernel       ; Let the kernel do initial setup.
                    jsr __krn_init
                    
                    ; Now tell it about the disk and filesystem drivers.
                    set a, [dd_drv_offset]
                    jsr __krn_drv_init_addr
                    
                    set a, [fs_drv_offset]
                    jsr __krn_drv_init_addr
                    
                    ; Clear the stack.
                    set sp, 0xffff
                    
                    ;
                    ; Here is the stack layout the kernel can expect:
                    ;
                    ; PICK 0:   boot_device_id
                    ; PICK 1:   scr_id
                    ; PICK 2:   scr_cur
                    ; PICK 3:   scr_format
                    ; PICK 4:   kb_id
                    ;
                    
                    set push, [kb_id]
                    set push, [scr_format]
                    set push, [scr_cur]
                    set push, [scr_id],
                    set push, [boot_dev_id]

                    ; Jump into the kernel
                    set pc, __krn_entry

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; halt()
                    ; -> DNR
                    ;  * -
                    ;
                    ; Halts the computer.
                    ;

:halt               sub pc, 1

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; memcpy(A = dst, B = src, C = len)
                    ; -> -
                    ;  * A B C I J
                    ;
                    ; Copies len words from src to dst.
                    ;

:memcpy             set push, i
                    set push, j
                    set i, a
                    set j, b

                    ; 8 * unrolled copy loop.
:.next8             ifl c, 8
                        set pc, .finish

                    sti [i], [j]
                    sti [i], [j]
                    sti [i], [j]
                    sti [i], [j]
                    sti [i], [j]
                    sti [i], [j]
                    sti [i], [j]
                    sti [i], [j]
                    sub c, 8
                    set pc, .next8

:.finish            ife c, 0
                        set pc, .return
                    sti [i], [j]
                    sub c, 1
                    set pc, .finish

:.return            set j, pop
                    set i, pop
                    set pc, pop
                    
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;
                    ; Static data.
                    ;

:FN_KERNEL          dat p"KERNEL\0\0SYS\0"
:MSG_FS_FAIL        dat p"Boot disk corrupted.\0"
:MSG_DNL_KERN       dat p"Cannot find KERNEL.SYS.\0"
:MSG_DNL_DD         dat p"Cannot find disk driver.\0"
:MSG_DNL_FS         dat p"Cannot find filesystem driver.\0"
:MSG_CANT_BOOT      dat p"System cannot boot.\0"

                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.org BOOT_END
                    sub pc, 1