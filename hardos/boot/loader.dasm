
.include "loader.i"
.include "../kernel/syscall.i"

;
; Variables.
;

.equ SCREEN_OFF     BOOT_VARS

;
; Constants.
;

.equ TRUE           1
.equ FALSE          0

.equ SUCCESS        1
.equ FAILURE        0

.equ LOAD_BASE      0x0000
.equ SCREEN_BASE    0x8000
.equ F_Wz           0xF000

.equ LEM_MEM_MAP_SCREEN     0
.equ LEM_MEM_MAP_FONT       1
.equ LEM_MEM_MAP_PALETTE    2
.equ LEM_SET_BORDER_COLOR   3

.org BOOT_ORG

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; boot(boot_device_id)
                ; -> DNR
                ;  * A B
                ;
                ; Begins the boot process.
                ;
                
:boot           set a, pop
                set sp, 0xffff ; throw away any extra parameters
                
                ; Initialise the screen.
                set push, a
                jsr scr_init
                set a, pop
                
                ; Initialise the disk driver.
                jsr dd_init
                ifn a, 1
                    set pc, .ddfail
                    
                ; Read second sector
                set a, 1
                set b, BOOT_HIGH
                jsr dd_read_sector
                
                set pc, boot2
                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; scr_init()
                ; -> void
                ;  * A B C X Y I
                ;
                ; Initialises the screen device.
                ;
                
:scr_init       set push, x
                set push, y
                set push, i
                hwn i
:.nextdev       sub i, 1
                ife i, 0xffff
                    jsr halt
                hwq i
                ifn a, 0xf615
                    set pc, .nextdev
                ifn b, 0x7349
                    set pc, .nextdev
                
                ; Found the screen.
                set [SCREEN_OFF], 0
                
                ; Reset the mem maps and border colour
                set a, LEM_MEM_MAP_SCREEN
                set b, 0
                hwi i
                
                set a, LEM_MEM_MAP_FONT
                set b, 0
                hwi i
                
                set a, LEM_MEM_MAP_PALETTE
                set b, 0
                hwi i
                
                set a, LEM_SET_BORDER_COLOR
                set b, 0
                hwi i
                
                ; Clear the screen ram
                set a, SCREEN_BASE+32*12
                set b, ' '
:.clearnext     set [a], b
                sub a, 1
                ifg a, SCREEN_BASE-1
                    set pc, .clearnext
                    
                ; Re-map screen
                set a, LEM_MEM_MAP_SCREEN
                set b, SCREEN_BASE
                hwi i
                
                ; All done!
                set i, pop
                set y, pop
                set x, pop
                set pc, pop
                
                ; Here's the way this words.  BOOT_CUTOFF will always be set
                ; to an address at or before 0x7200.  All code needed to
                ; initialise the disk drive and read in the portions of the
                ; bootloader above 0x7200 *must* fit below this cut-off.
                ; The screen initialisation got thrown in because there was
                ; room; waste not, want not!
.org BOOT_CUTOFF
                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; boot2()
                ; -> DNR
                ;  * A B X
                ;
                ; Continues boot.
                ;
                
:boot2          ; Initialise the filesystem driver.
                jsr fs_init
                ifn a, SUCCESS
                    set pc, .fsfail
                    
                ; Device driver and filesystem init'ed OK.
                ; Locate the kernel and load into memory.
                set x, LOAD_BASE
                set a, FN_KERNEL
                set b, x
                jsr load_file
                ifn a, SUCCESS
                    set pc, .dnl_kernel
                    
                add x, b
                
                jsr dd_get_driver
                set b, x
                jsr load_file
                ifn a, SUCCESS
                    set pc, .dnl_dd
                
                add x, b
                
                jsr fs_get_driver
                set b, x
                jsr load_file
                ifn a, SUCCESS
                    set pc, .dnl_fs
                
                ; All done!
                jsr start_kernel
                
:.ddfail        set a, MSG_DD_FAIL
                jsr scr_putpsz
                jsr halt

:.fsfail        set a, MSG_FS_FAIL
                jsr scr_putpsz
                jsr halt
                
:.dnl_kernel    set a, MSG_DNL_KERN
                set pc, .dnl_tail

:.dnl_dd        set a, MSG_DNL_DD
                set pc, .dnl_tail

:.dnl_fs        set a, MSG_DNL_FS
                set pc, .dnl_tail
                
:.dnl_tail      jsr scr_putpsz
                jsr scr_nl
                set a, MSG_CANT_BOOT
                jsr scr_putpsz
                jsr halt
                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; load_file(A = path, B = dest)
                ; -> A = success, B = size
                ;  * A B C X Y
                ;
                ; Loads a file into memory at the specified base address.
                ; Returns the number of words loaded.
                ;
                
:load_file      set push, x
                set push, y
                set x, b
                
                jsr fs_find_file
                ife a, FAILURE
                    set pc, .fail0
                
                set a, b
                jsr fs_open_handle
                ife a, FAILURE
                    set pc, .fail0
                
                set push, a
                set y, 0
:.next          set a, peek
                jsr fs_read ; -> A = success, B = buffer, C = words_read
                ife a, FAILURE
                    set pc, .fail1
                    
                ife c, 0
                    set pc, .done
                
                set a, x
                add x, c
                add y, c
                jsr memcpy
                set pc, .next
                
:.fail0         set y, pop
                set x, pop
                set pc, pop
                
:.fail1         add sp, 1
                set a, FAILURE
                set y, pop
                set x, pop
                set pc, pop
                
:.done          add sp, 1
                set a, SUCCESS
                set b, y
                set y, pop
                set x, pop
                set pc, pop

                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; start_kernel()
                ; -> DNR
                ;  * -
                ;
                ; Starts the kernel up.
                ;
                
:start_kernel   ; Clear the stack.
                set sp, 0xffff
                ; Jump into the kernel
                set pc, __krn_entry
                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; halt()
                ; -> DNR
                ;  * -
                ;
                ; Halts the computer.
                ;

:halt           sub pc, 1

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; memcpy(A = dst, B = src, C = len)
                ; -> -
                ;  * A B C I J
                ;
                ; Copies len words from src to dst.
                ;
                
:memcpy         set push, i
                set push, j
                set i, a
                set j, b
                
                ; 8 * unrolled copy loop.
:.next8         ifl c, 8
                    set pc, .finish
                    
                sti [i], [j]
                sti [i], [j]
                sti [i], [j]
                sti [i], [j]
                sti [i], [j]
                sti [i], [j]
                sti [i], [j]
                sti [i], [j]
                sub c, 8
                set pc, .next8
                
:.finish        ife c, 0
                    set pc, .return
                sti [i], [j]
                sub c, 1
                set pc, .finish
                
:.return        set j, pop
                set i, pop
                set pc, pop
                
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; scr_putpsz(A = psz, B = format)
                ; -> -
                ;  * A B C I
                ;
                ; Puts a given packed, zero-terminated screen to the screen.
                ; It will correctly interpret \n and \r\n newline sequences,
                ; but nothing else.
                ;
                
:scr_putpsz     set push, i
                set c, [SCREEN_OFF]
                add c, SCREEN_BASE
                
                ; Put high character
:.next0         set i, [a]
                shr i, 8
                and i, 0x7f
                ife i, 0
                    set pc, .done_0
                ife i, 0x0d
                    set pc, .next1
                ife i, 0x0a
                    set pc, .nl0
:.print0        bor i, b
                set [c], i
                
                ; Put low character
:.next1         add c, 1
                set i, [a]
                and i, 0x7f
                ife i, 0
                    set pc, .done_0
                ife i, 0x0d
                    set pc, .next2
                ife i, 0x0a
                    set pc, .nl1
:.print1        bor i, b
                set [c], i
                
:.next2         add c, 1
                add a, 1
                set pc, .next0
                
                ; High newline
:.nl0           set push, a
                jsr scr_nl
                set a, pop
                set c, [SCREEN_OFF]
                add c, SCREEN_BASE
                set pc, .next1

                ; Low newline
:.nl1           set push, a
                jsr scr_nl
                set a, pop
                set c, [SCREEN_OFF]
                add c, SCREEN_BASE
                set pc, .next2
                
:.done_0        set i, pop
                set pc, pop

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; scr_nl()
                ; -> -
                ;  * A
                ;
                ; Move to the next line on the screen.
                ; TODO: Scroll the screen up when at the bottom.
                ;
                
:scr_nl         set a, [SCREEN_OFF]
                and a, 0xFFDF
                add a, 1
                ife a, 12
                    set a, 0
                
                set [SCREEN_OFF], a

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;
                ; Static data.
                ;
                
:FN_KERNEL      dat p"KERNEL\0\0SYS\0"
:MSG_DD_FAIL    dat p"Disk drive failure.\0"
:MSG_FS_FAIL    dat p"Boot disk corrupted.\0"
:MSG_DNL_KERN   dat p"Cannot find KERNEL.SYS.\0"
:MSG_DNL_DD     dat p"Cannot find disk driver.\0"
:MSG_DNL_FS     dat p"Cannot find filesystem driver.\0"
:MSG_CANT_BOOT  dat p"System cannot boot.\0"

                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.org BOOT_END
                sub pc, 1